# Імпортуємо deque (двостороння черга) для ефективної роботи з чергами, що потрібна для BFS.
from collections import deque
# Імпортуємо networkx для побудови та маніпуляцій з графом.
import networkx as nx
# Імпортуємо matplotlib.pyplot для візуалізації графа (малювання).
import matplotlib.pyplot as plt

# --- 1. Алгоритм Едмондса-Карпа ---

# Визначення функції BFS (пошук в ширину) для знаходження збільшуючого шляху в залишковому графі.
def bfs(capacity_matrix, flow_matrix, source, sink, parent):
    """Шукає шлях від source до sink у залишковому графі (BFS)."""
    # Отримуємо загальну кількість вузлів у графі (розмір матриці).
    num_nodes = len(capacity_matrix)
    # Створюємо масив для відстеження відвіданих вузлів, ініціалізуючи всі як False.
    visited = [False] * num_nodes
    # Ініціалізуємо чергу, додаючи вихідний вузол (source).
    queue = deque([source])
    # Позначаємо вихідний вузол як відвіданий.
    visited[source] = True
    
    # Головний цикл BFS: продовжуємо, доки черга не порожня.
    while queue:
        # Витягуємо поточний вузол (u) з початку черги.
        u = queue.popleft()
        
        # Перебираємо всі можливі вузли (v) як потенційних сусідів.
        for v in range(num_nodes):
            # Перевіряємо, чи є залишкова пропускна здатність на ребрі (u, v) > 0.
            if not visited[v] and capacity_matrix[u][v] - flow_matrix[u][v] > 0:
                # Встановлюємо u як батьківський вузол для v (для відновлення шляху).
                parent[v] = u
                # Позначаємо v як відвіданий.
                visited[v] = True
                # Якщо сусід v — це стік (мета), шлях знайдено.
                if v == sink:
                    return True  # Повертаємо True.
                # Додаємо v до черги для подальшого дослідження.
                queue.append(v)
                
    # Якщо цикл завершився і стік не був досягнутий, шлях відсутній.
    return False

# Визначення основної функції алгоритму Едмондса-Карпа.
def edmonds_karp(capacity_matrix, source, sink):
    """Обчислює максимальний потік з source до sink."""
    # Загальна кількість вузлів.
    num_nodes = len(capacity_matrix)
    # Ініціалізація матриці потоку нулями.
    flow_matrix = [[0] * num_nodes for _ in range(num_nodes)] 
    # Масив для батьківських вузлів (заповнюється BFS).
    parent = [-1] * num_nodes
    # Ініціалізація максимального потоку.
    max_flow = 0
    
    # Головний цикл: повторюємо, доки BFS знаходить збільшуючий шлях.
    while bfs(capacity_matrix, flow_matrix, source, sink, parent):
        # Ініціалізуємо потік на шляху як нескінченність (для пошуку мінімуму).
        path_flow = float('Inf')
        # Починаємо з кінцевого вузла (стік).
        s = sink
        
        # Рухаємося від стоку до джерела для визначення вузького місця.
        while s != source:
            # u — попередній вузол (батько) s.
            u = parent[s]
            # Знаходимо вузьке місце: мінімальну залишкову пропускну здатність на шляху.
            path_flow = min(path_flow, capacity_matrix[u][s] - flow_matrix[u][s])
            # Переходимо до попереднього вузла.
            s = u
            
        # Починаємо знову від стоку для оновлення потоків.
        v = sink
        # Рухаємося від стоку до джерела для оновлення потоків.
        while v != source:
            # u — попередній вузол v.
            u = parent[v]
            # Збільшуємо прямий потік на знайдену величину path_flow.
            flow_matrix[u][v] += path_flow
            # Зменшуємо (або збільшуємо) зворотний потік (ключ до алгоритму Едмондса-Карпа).
            flow_matrix[v][u] -= path_flow 
            # Переходимо до попереднього вузла.
            v = u
            
        # Збільшуємо загальний максимальний потік.
        max_flow += path_flow
        
    # Повертаємо загальний максимальний потік та фінальну матрицю потоків.
    return max_flow, flow_matrix

# --- 2. Побудова Графа та Матриці Пропускної Здатності  ---

# Створення словника для відображення імен вузлів на їх числові індекси (0-21).
# Всього 22 унікальних вузли (20 логістичних + S + T).
# Віртуальні вузли S (Джерело) і T (Стік) потрібні для застосування стандартних 
# алгоритми графового пошуку  (в т.ч. алгоритму Едмондса-Карпа) - необхідно щоб граф 
# мав один вхід (Source, S) та один вихід (Sink, T), що є фундаментальною вимогою
# для моделювання максимального потоку в графах з багатьма джерелами/стоками,
nodes = {
    'S': 0, 
    'Термінал 1': 1, 'Термінал 2': 2,
    'Склад 1': 3, 'Склад 2': 4, 'Склад 3': 5, 'Склад 4': 6,
    'Магазин 1': 7, 'Магазин 2': 8, 'Магазин 3': 9, 'Магазин 4': 10, 'Магазин 5': 11,
    'Магазин 6': 12, 'Магазин 7': 13, 'Магазин 8': 14, 'Магазин 9': 15, 'Магазин 10': 16,
    'Магазин 11': 17, 'Магазин 12': 18, 'Магазин 13': 19, 'Магазин 14': 20, 
    'T': 21 # T тепер має унікальний індекс 21.
}
# Загальна кількість вузлів тепер 22 (індекси 0-21).
num_nodes = 22 
# Велике число, що позначає необмежену пропускну здатність.
INF = 1000 
# Ініціалізація матриці пропускної здатності розміром 22x22 нулями.
capacity_matrix = [[0] * num_nodes for _ in range(num_nodes)]

# Список ребер у форматі (початок, кінець, пропускна здатність).
edges = [
    ('S', 'Термінал 1', INF), ('S', 'Термінал 2', INF), # S з'єднує Термінали.
    # Термінали -> Склади (Згідно з таблицею)
    ('Термінал 1', 'Склад 1', 25), ('Термінал 1', 'Склад 2', 20), ('Термінал 1', 'Склад 3', 15),
    ('Термінал 2', 'Склад 3', 15), ('Термінал 2', 'Склад 4', 30), ('Термінал 2', 'Склад 2', 10),
    # Склади -> Магазини (Згідно з таблицею)
    ('Склад 1', 'Магазин 1', 15), ('Склад 1', 'Магазин 2', 10), ('Склад 1', 'Магазин 3', 20),
    ('Склад 2', 'Магазин 4', 15), ('Склад 2', 'Магазин 5', 10), ('Склад 2', 'Магазин 6', 25),
    ('Склад 3', 'Магазин 7', 20), ('Склад 3', 'Магазин 8', 15), ('Склад 3', 'Магазин 9', 10),
    ('Склад 4', 'Магазин 10', 20), ('Склад 4', 'Магазин 11', 10), ('Склад 4', 'Магазин 12', 15),
    ('Склад 4', 'Магазин 13', 5), ('Склад 4', 'Магазин 14', 10)
]

# Заповнення матриці пропускної здатності даними з edges.
for u_name, v_name, cap in edges:
    u = nodes[u_name]
    v = nodes[v_name]
    capacity_matrix[u][v] = cap

# Список імен магазинів.
shops = [f'Магазин {i}' for i in range(1, 15)]
# Індекс Суперстоку.
T_index = nodes['T']
# З'єднання всіх магазинів зі Суперстоком (T).
for shop_name in shops:
    # capacity_matrix[nodes[shop_name]][T_index] = INF - Ми можемо встановлювати реальну потребу магазину
    # Якщо припустити, що потреба магазину 1-14 обмежена його пропускною здатністю, 
    # а потік в T повинен бути необмеженим, щоб не впливати на Min-Cut, 
    # залишаємо INF (нескінченність).
    capacity_matrix[nodes[shop_name]][T_index] = INF 

# --- 3. Побудова Графа для Візуалізації (NetworkX) ---

# Створення орієнтованого графа NetworkX.
G = nx.DiGraph()

# Збираємо всі ребра у форматі (u_idx, v_idx, capacity) для NetworkX.
all_edges_for_graph = []
for u_name, v_name, cap in edges:
    all_edges_for_graph.append((nodes[u_name], nodes[v_name], cap))
# Додаємо ребра Магазини -> T.
for shop_name in shops:
    all_edges_for_graph.append((nodes[shop_name], T_index, capacity_matrix[nodes[shop_name]][T_index]))

# Додавання всіх ребер до графа G.
G.add_weighted_edges_from(all_edges_for_graph)

# Словник для відображення індексів на імена вузлів.
node_labels = {idx: name for name, idx in nodes.items()}

# Створення позицій (координат) для візуалізації, що відповідають схемі.
pos = {}
# Позиції для S та T (віртуальні)
pos[nodes['S']] = (0, 0)
pos[nodes['T']] = (12, 0) # Зміщено T, щоб відокремити від M14 (20).

# Позиції для логістичних вузлів
pos[nodes['Термінал 1']] = (3, 3)
pos[nodes['Термінал 2']] = (3, -3)
pos[nodes['Склад 1']] = (6, 4)
pos[nodes['Склад 2']] = (6, 2)
pos[nodes['Склад 3']] = (6, -2)
pos[nodes['Склад 4']] = (6, -4)

# Встановлення позицій для всіх магазинів.
shop_positions = {
    'Магазин 1': (9, 5.0), 'Магазин 2': (9, 4.0), 'Магазин 3': (9, 3.0), 'Магазин 4': (9, 2.0), 
    'Магазин 5': (9, 1.0), 'Магазин 6': (9, 0.0), 'Магазин 7': (9, -1.0), 'Магазин 8': (9, -2.0),
    'Магазин 9': (9, -3.0), 'Магазин 10': (9, -4.0), 'Магазин 11': (9, -5.0), 'Магазин 12': (9, -6.0),
    'Магазин 13': (9, -7.0), 'Магазин 14': (9, -8.0) 
}

for name, coord in shop_positions.items():
    pos[nodes[name]] = coord

# --- 4. Візуалізація Графа (Блок закоментовано) ---

# Блок візуалізації закоментовано, оскільки виконання графічних команд (plt.show())
# не підтримується у текстовому середовищі.
# plt.figure(figsize=(15, 12))
# nx.draw(G, pos, with_labels=False, node_size=1500, node_color="lightblue", font_size=10, font_weight="bold", arrows=True)
# nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=8)
# edge_labels = nx.get_edge_attributes(G, 'weight')
# nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red')
# plt.title("Логістична мережа з пропускними здатностями (Max Flow Model)")
# plt.show()

# --- 5. Виконання Алгоритму та Реконструкція Потоку ---

# Встановлюємо індекс джерела (S).
source_node = nodes['S']
# Встановлюємо індекс стоку (T).
sink_node = nodes['T']
# Запускаємо алгоритм Едмондса-Карпа.
max_flow, flow_matrix = edmonds_karp(capacity_matrix, source_node, sink_node)

# Словник для оберненого пошуку імен вузлів.
reverse_nodes = {v: k for k, v in nodes.items()}
# Списки терміналів і складів.
terminals = ['Термінал 1', 'Термінал 2']
warehouses = ['Склад 1', 'Склад 2', 'Склад 3', 'Склад 4']

# Логіка Реконструкції Потоку: Крок 1 (Вхід у Склади)
warehouse_inflow = {w: 0 for w in warehouses}
for w in warehouses:
    w_idx = nodes[w]
    # Сумарний потік у склад W з усіх терміналів
    inflow_sum = sum(flow_matrix[nodes[t]][w_idx] for t in terminals)
    warehouse_inflow[w] = inflow_sum

# Логіка Реконструкції Потоку: Крок 2 (Частка Термінала у потоці до Складу)
term_to_warehouse_share = {t: {} for t in terminals}
for t in terminals:
    t_idx = nodes[t]
    for w in warehouses:
        w_idx = nodes[w]
        inflow = flow_matrix[t_idx][w_idx]
        total_inflow = warehouse_inflow[w]
        # Частка Термінала t у загальному потоці Складу w.
        share = inflow / total_inflow if total_inflow > 0 else 0
        term_to_warehouse_share[t][w] = share

# Логіка Реконструкції Потоку: Крок 3 (Розподіл до Магазинів)
term_to_shop_flow = {t: {s: 0 for s in shops} for t in terminals}
for w in warehouses:
    w_idx = nodes[w]
    for s in shops:
        s_idx = nodes[s]
        warehouse_to_shop_flow = flow_matrix[w_idx][s_idx] # Потік Склад -> Магазин.
        
        for t in terminals:
            share = term_to_warehouse_share[t].get(w, 0)
            # Розподіляємо потік Склад -> Магазин пропорційно часткам Терміналів.
            term_to_shop_flow[t][s] += warehouse_to_shop_flow * share

# Форматування результатів у фінальну таблицю.
final_report_table = []
for t in terminals:
    for s in shops:
        flow = round(term_to_shop_flow[t][s]) # Округлення для читабельності.
        final_report_table.append({'Термінал': t, 'Магазин': s, 'Фактичний Потік': flow})

# Збір загальних потоків у Магазини (для аналізу).
shop_flows = []
for s in shops:
    # Потік Магазин -> T дорівнює фактичному потоку в Магазин.
    actual_flow_to_shop = flow_matrix[nodes[s]][T_index]
    shop_flows.append({
        'Магазин': s,
        'Потік до Магазину': actual_flow_to_shop
    })


# --- 5. Вивід Звіту та Аналіз  ---

# Обчислення необхідних змінних для звіту
flow_term1 = sum(item['Фактичний Потік'] for item in final_report_table if item['Термінал'] == 'Термінал 1')
flow_term2 = sum(item['Фактичний Потік'] for item in final_report_table if item['Термінал'] == 'Термінал 2')
# Сумарна пропускна здатність на розрізі Склади -> Магазини
min_cut_capacity = sum(capacity_matrix[nodes[w]][nodes[s]] for w in warehouses for s in shops)
max_shop_flow = max(shop_flows, key=lambda x: x['Потік до Магазину'])


# 5.0. Вивід Максимального Потоку
print(f"✅ Максимальний потік у мережі: {max_flow} одиниць")
print("----------------------------------------------------------------------")
print("📊 Звіт: Аналіз Логістичної Мережі Максимального Потоку")
print("----------------------------------------------------------------------")

# 5.1. Пояснення моделі та обчислення
print("\n=== Пояснення Моделі та Результати Обчислень ===")
print("Побудована модель графа коректно відображає логістичну мережу з 2 Терміналами, 4 Складами та 14 Магазинами, об'єднаними Суперджерелом (S)  та Суперстоком (T).")
print(f"Розрахунок алгоритму Едмондса-Карпа показав, що максимальний обсяг постачання становить {max_flow} одиниць.")
# print("Це значення підтверджує Теорему про мінімальний розріз-максимальний потік.")
# print("Таким чином, досягнуто оптимального потоку.")
print("----------------------------------------------------------------------")

# 5.2. Таблиця Потоків
print("\n=== Таблиця: Фактичний Потік Термінал -> Магазин ===")
header = f"{'Термінал':<12} | {'Магазин':<10} | {'Фактичний Потік (одиниць)':<25}"
print(header)
print("-" * len(header))
for item in final_report_table:
    print(f"{item['Термінал']:<12} | {item['Магазин']:<10} | {item['Фактичний Потік']:<25}")
print("-" * 70)


print("\n--- Аналіз Отриманих Результатів та Відповіді на Запитання ---")

# 1. Які термінали забезпечують найбільший потік товарів до магазинів?
print("\n1. Які термінали забезпечують найбільший потік товарів до магазинів?")
if flow_term1 == flow_term2:
    print(f"Термінал 1 постачає {flow_term1} одиниць. Термінал 2 постачає {flow_term2} одиниць.")
    print("Обидва термінали забезпечують однаковий потік.")
elif flow_term1 > flow_term2:
    print(f"Термінал 1 постачає {flow_term1} одиниць. Термінал 2 постачає {flow_term2} одиниць.")
    print(f"Термінал 1 забезпечує більший потік.")
else:
    print(f"Термінал 1 постачає {flow_term1} одиниць. Термінал 2 постачає {flow_term2} одиниць.")
    print(f"Термінал 2 забезпечує більший потік.")


# 2. Які маршрути мають найменшу пропускну здатність і як це впливає на загальний потік?
print("\n2. Які маршрути мають найменшу пропускну здатність і як це впливає на загальний потік?")
print(f"Найменша сумарна пропускна здатність (мінімальний розріз) знаходиться на розрізі Склади -> Магазини ({min_cut_capacity} одиниць).")
print(f"Це вузьке місце критично лімітує загальний потік мережі до {max_flow} одиниць.")
# Пошук мінімального індивідуального ребра
min_cap_edge = min(edges, key=lambda x: x[2])
print(f"Індивідуально найменший канал: {min_cap_edge[0]} -> {min_cap_edge[1]} ({min_cap_edge[2]} одиниць).")


# 3. Які магазини отримали найменше товарів і чи можна збільшити їх постачання?
min_flow_value = min(item['Потік до Магазину'] for item in shop_flows)
min_flow_shops = [item['Магазин'] for item in shop_flows if item['Потік до Магазину'] == min_flow_value]
min_flow_shops_names = [name.split(' ')[1] for name in min_flow_shops] 

if len(min_flow_shops) > 1:
    shops_list_str = ', '.join(min_flow_shops_names[:-1]) + f" та {min_flow_shops_names[-1]}"
else:
    shops_list_str = min_flow_shops_names[0]

print("\n3. Які магазини отримали найменше товарів і чи можна збільшити їх постачання?")
print(f"Найменше товарів ({min_flow_value} одиниць) отримали Магазин(и) {shops_list_str}.")
print(f"Найбільше товарів отримав Магазин {max_shop_flow['Магазин'].split(' ')[1]} ({max_shop_flow['Потік до Магазину']} одиниць).")
print(f"Так, постачання цих магазинів можна збільшити, збільшивши пропускну здатність відповідних маршрутів.")


# 4. Чи є вузькі місця, які можна усунути для покращення ефективності логістичної мережі?
print("\n4. Чи є вузькі місця, які можна усунути для покращення ефективності логістичної мережі?")
print("Так. Головне вузьке місце – це сукупність усіх ребер від Складів до Магазинів.")
print("Для збільшення загального максимального потоку (підвищення ефективності) необхідно інвестувати у збільшення пропускної здатності на цій ділянці логістичного ланцюга. ")
print(f"Фактично, мінімальний розріз (вузьке місце) дорівнює максимальному потоку: {max_flow} одиниць. Збільшення пропускної здатності на будь-якому ребрі, що належить мінімальному розрізу, збільшить загальний потік.")
